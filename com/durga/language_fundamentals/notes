=>Identifiers:
->a name in python program is called identifier. It can be a class name or variable name or method name.

=>Data Types:
int, float, complex, bool, str
-the above data type considered as fundamental data type.
-long data type only available in python2 but in python3.
-there is no char data type in python, char values also we can represent by using str type only.
list, tuple, set, frozenset, dict
bytes, bytearray, range, None
->binary, octal, hexadecimal representaion only applicable for integral values.
f=123
->floating point values we should represent in decimal form only. binary, octal, hexadecimal form not allowed.
f=0b10.1111(not allowed)
f=1.2e3(exponential representation, within the less space we can represent bigger value)
print(f)->1.2*1000=1200.0
f=12000000000000000.0->f=1.2e16

->complex data type:
if we want to develop scientific, mathematics, electrical engineering based applications this data type very helpful.
a+bj
a=real part, b=imaginary part, j=j2-1 i.e j=sqrt root -1
j symbol is compulsory.
x=10+20j
print(type(x))->complex
print(x.real)->10.0
print(x.imag)->20.0

x=10.5+20j(acceptable)
x=10.5+20.6j(acceptable)

-real part value can be represented in binary, octal, hexadecimal form, but imaginary part value can only represented
 in decimal form.
x=0b1111+20j(acceptable)
x=15+0B1111j(not acceptable)

-we can perform arithmetic operation between two complex numbers.
x=10+20j
y=20+30j
print(x+y)->30+50j
print(x*y)->-400+700j
print(x/y)->0.6138...+0.07692...j

->str data type:
s="durga"
#s='durga'
print(type(s))->str
-in python there is no char data type.Even a single character in single quote also treated as string only.
s='a'
print(type(s))->str
-python supports triple single quote or triple double quote with string.
->Benefit of triple single/double quote in string:
-to define multiline string literals
-to use single/double quote as normal character in string.
-to define doc string

->to define multiline string literals:
eg1;
s='durga
 software
 solutions'
print(s)->SyntaxError: EOL while scanning string literal.
s='''durga
 software
 solutions'''
print(s)->
durga
 software
 solutions

->to use single/double quote as normal character in string:
s='class by 'durga' is very good'
print(s)->SyntaxError: invalid syntax
s="class by 'durga' is very good"
print(s)->class by 'durga' is very good

s='class by "durga" is very good'
print(s)->class by "durga" is very good

s=classes by 'durga' for "python" are very good
print(s)->SyntaxError: invalid syntax

s='''classes by 'durga' for "python" are very good'''
print(s)->classes by 'durga' for "python" are very good

->to define doc string:
----------------------------------------------------
-python provide support for both +ve and -ve index. +ve index starts(from 0) in forward direction whereas -ve index
 starts(from -1) in backward direction.
s='durga'
print(s[0])->d
print(s[3])->g
print(s[100])->IndexError: string index out of range

print(s[-1])->a(it gives last character of string)

slice operator:s[begin:end]
-It returns substring(slice) from begin index to end-1 index.
-slice means one piece. To get part of the string from a string
s='abcdefghijklmnopqrstuvwxyz'
print(s[3:9])->returns 3 to 8 index
defghi

-if we are not specifying the begin index then the default is begining index i.e 0.
-if we are not specifying end index the it will consider until end index.
-if we are not specifying both begin and end index then it will return original string.

print(s[:9])->will return 0 to 8 index.
print(s[3:])->will return from 3rd index to till last index.
print(s[:])->will return original string.
print(s[3:1000])->will return from 3rd index to till last index.
print(s[5:1])->will return empty string, because +ve index move in forward direction and after 5th index first index
               will never come and hence it will return empty string.
input='durga'
output=s[0:len(s)-1]+s[-1].upper()//durgA

input='durga'
output=s[0].upper()+s[1:len(s)-1]//Durga

+ operator:
s='durga'+'soft'
print(s)->durgasoft
s='durga'+10
print(s)->TypeError:must be str, not int
-both argument must be string.

* operator:
-also called string repetition operator.
-compulsory one argument should be int.
s='durga'*3
print(s)->durgadurgadurga

s=3*'durga'
print(s)->durgadurgadurga

s='durga'*'soft'
print(s)->TypeError: can't multiply sequence by non-int of type 'str'

print('#'*30)
print('DURGASOFT')
print('#'*30)
output:
##############################
DURGASOFT
##############################

=>Reserved words/keyword:

->The word which are reserved to represent some meaning or functionalities.
->There are total 33 reserved words in python, there are below,
True, False, None
and, or, not, is
if, elif, else
while, for, break, continue, return, in, yield
try, except, finally, raise, assert
import, from, as, class, def, pass
global, nonlocal, lambda, del, with

->contains only alphabet symbols.
->except the following 3 all contains only lower case alphabet symbol. True, False, None
->swith, do-while not there in python.
->int, float, boolean etc. such type of reserved words are not there in python, since python is dynamically
 typed language.
->practically list down the reserved words.
import keyword
keyword.kwlist

=>Base conversion functions:
1>bin()->to get binary representation of a given number.
2>oct()->to get octal representation of a given number.
3>hex()->to get hexadecimal representation of a given number.

1>bin():
eg1;
bin(15)->0b1111
eg2;
bin(0o123)->0b1010011
eg3;
bin(0XFace)->0b1111101011001110

2>oct();
eg1;
oct(100)->0o144
eg2;
oct(0b111101)
0o75
eg3;
oct(oXFace)->0o175316

3>hex():
eg;
hex(1000)->0x3e8
eg2;
hex(0b10111111)->0xbf
eg3;
hex(0o123456)->0xa72e

->all above base functions are applicable only for integral numbers.
->if i want to convert the number to decimal, what is the function?
Ans:to convert into decimal no function required, because default number system is decimal only.
--------------------------------------------------------------------------------------------------------
Type casting:
-process of converting one type to another.
int()
float()
complex()
bool()
str()

1>int():
-to convert from other types to int.
a>float->int:
int(10.989)->10
the digits after decimal point will be gone.

b>complex->int:
int(10+20j)->TypeError: can't convert complex to int
-complex number can not be converted to int type.

c>bool->int:
int(True)->1
int(False)->0

d>str->int:
-compulsory string should contail integral value and base 10.
int('15')->15
int('0B1111')->ValueError: invalid literal for int() with base 10: '0B1111'
int('10.5')->ValueError: invalid literal for int with base 10: 10.5

2>float:
-to convert from other types to float.
a>int->float:
float(15)->15.0
float(0B1111)->15.0
float(0XFace)->64206.0

b>complex to float:
float(10+20j)->ValueError: cant convert complex to float

c>bool->float:
float(True)->1.0
float(False)->0.0

d>str->float:
-internally string should contain either int/float value in base 10.
float("10")->10.0
float("20.6")->20.6
float("0XFace")->VE:could not convert string to float: '0XFACE'
float("durga")->VE: could not convert string to float: 'durga'

3>complex:
-to convert from other type to complex.
a>form1 complex(x):
complex(10)->10+0j
complex(0B1111)->15+0j
complex(10.5)->10.5+0j
complex(True)->1+0j
complex(False)->0+0j=0j
complex("10")->10+0j
complex("0B1111")->ValueError: complex() arg is a malformed string

b>form2 complex(x,y):
complex(10,20)->10+20j
complex(10.5,20.6)->10.5+20.6j
complex("10","20")->TE:complex() cant take second arg if first is a string.
complex(10,"20)->TE:complex() second arg cant be a string.

4)bool():
-to convert from other type to boolean.
a>int argument:
bool(1)->True
bool(10)->True
bool(-10)->True
bool(0)->False

b>float argument:
bool(0.0)->False
bool(0.1)->True
bool(0.00001)->True
bool(-0.00001)->True

c>complex argument:
-if both real and imaginary part are 0 then False else True.
bool(0+0j)->False
bool(1+0j)->True

d>str argument:
bool('True')->True
bool('False')->True
bool('yes')->True
bool('no')->True
bool('')->False

5>str():
-to convert from other type to str.
str(10)->'10'
str(0B1111)->'15'
str(10.5)->'10.5'
str(10+20j)->'10+20j'
str(True)->'True'
str(False)->'False'
-------------------------------------------------------------------------
video34:Fundamental data type vs immutability:
-mutable means we can change or changeable
-immutable means we can not change or non changeable

->all fundamental data types are immutable
-once we create an object we cant perform any change in that object. If we are trying to perform any changes, with
 those changes a new object will be created.

-if any object is not having any reference such object will be destroyed by garbage collector.
x=10
print(id(x))->some id
x=x+1
print(id(x))->different id than above id, it means that its immutable

x=10
y=x
print(id(x))->some address
print(id(y))->same address as above
y=y+1
print(id(y))->now will different address

a=10
b=20
c=30
how many object will be created? answer is one
print(id(a))
print(id(b))
print(id(c))
If object already there with required content it will use existing object. Its called object reusability.
-biggest advantage is memory utilization/performance will get improved.

a=1000.234
b=1000.234
print(id(a))->some address
print(id(b))->same address
print(a is b)->True(It proves that both reference a and b pointing to same object)

a=True
b=True
print(a is b)->True

a='durgasoft'
b='durgasoft'
print(a is b)->True

->We may have doubt like if python virtual machine everytime will search object already there or not it may down
  performance.Yes, but search operation is better that creation because search is faster that creation.















